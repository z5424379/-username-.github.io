<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/badline/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/badline/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/badline/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/badline/images/logo.svg" color="#222">

<link rel="stylesheet" href="/badline/css/main.css">


<link rel="stylesheet" href="/badline/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"z5424379.github.io","root":"/badline/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="主要编程语言: Python, C">
<meta property="og:type" content="website">
<meta property="og:title" content="代码随想录23期算法训练营">
<meta property="og:url" content="https://z5424379.github.io/badline/index.html">
<meta property="og:site_name" content="代码随想录23期算法训练营">
<meta property="og:description" content="主要编程语言: Python, C">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Badline">
<meta property="article:tag" content="Python, C">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://z5424379.github.io/badline/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>代码随想录23期算法训练营</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/badline/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">代码随想录23期算法训练营</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/badline/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/badline/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/z5424379/algorithm.github.io" class="github-corner" title="Badline Github" aria-label="Badline Github" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/10/04/day12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/10/04/day12/" class="post-title-link" itemprop="url">Day12：239. 滑动窗口最大值 347.前 K 个高频元素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-04 17:16:04" itemprop="dateCreated datePublished" datetime="2023-10-04T17:16:04+11:00">2023-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-05 23:12:01" itemprop="dateModified" datetime="2023-10-05T23:12:01+11:00">2023-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自己写一个单调队列, 需要保证队列是从大到小的, 一个新元素进来的时候, 将比这个新元素小的队尾一个个 pop 掉, 这样保证整个队列后面的值是小于等于前面的值的, 那么队头就是最大的.<br>当窗口滑动的时候, 如果左边被滑出去的值跟队头一样, 那就从队头 popleft. 然后右边添加进来的新元素加入到单调队列中.<br>注意后面的值是可能等于前面的值的, 这样是为了保证类似<code>3, 3, 3, -1, -2</code>这种情况, 窗口滑动时第一个 3 出去, 还能有两个 3.<br>如果把等于的也剔除掉, 就会出现明明窗口里还有 3, 但是队列里已经没有了的情况</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义单调队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque() <span class="comment"># 用双向队列deque来实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 如果队头的值等于value的话, 就把队头移出去</span></span><br><span class="line">        <span class="keyword">if</span> self.queue <span class="keyword">and</span> self.queue[<span class="number">0</span>] == value:</span><br><span class="line">            self.queue.popleft()    <span class="comment"># list移除第一个元素的话需要O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 如果队尾比value小的话, 就把队尾移除, 保证队列是单调非增的</span></span><br><span class="line">        <span class="keyword">while</span> self.queue <span class="keyword">and</span> self.queue[-<span class="number">1</span>] &lt; value:</span><br><span class="line">            self.queue.pop()</span><br><span class="line">        self.queue.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询队列的最大值, 也就是队头</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = MyQueue()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 先添加前k个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        <span class="comment"># res记录前k个元素的最大值</span></span><br><span class="line">        res.append(que.front())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 窗口左边的被移出去了</span></span><br><span class="line">            que.pop(nums[i-k])</span><br><span class="line">            <span class="comment"># 窗口右边的添加进来</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            <span class="comment"># 记录当前窗口的最大值</span></span><br><span class="line">            res.append(que.front())</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(k) 队列里面最多有 k 个元素</p>
<h3 id="C-思路"><a href="#C-思路" class="headerlink" title="C 思路"></a>C 思路</h3><p>C 里面没有双端队列, 所以也得自己定义结构, 只需要一个大小为 k 的队列就可以了.<br>head 表示队列的头, tail 表示队列的尾, 如果<code>head&gt;=tail</code>就说明这个队列是空的.<br>当 tail 超过 k 时, 因为我们知道这个队列里面最多只会有 k 个元素, 说明前面的<code>head%k</code>位置的元素是已经被废弃了的, 可以直接覆盖掉<br>然后查询的时候也是一样的使用<code>head%k</code>和<code>tail%k</code>来查询</p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 自定义一个单调队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyQueue</span>&#123;</span></span><br><span class="line">    <span class="type">int</span>* q;</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(MyQueue* que, <span class="type">int</span> value, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空且队头为value, 则把队头弹出去, 这里只维护一个大小为k的队列</span></span><br><span class="line">    <span class="keyword">if</span>(que-&gt;head &lt; que-&gt;tail &amp;&amp; que-&gt;q[que-&gt;head%k]==value)&#123;</span><br><span class="line">        que-&gt;head++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(MyQueue* que, <span class="type">int</span> value, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空且队尾小于value, 把队尾弹出去, 保证队列是从大到小的</span></span><br><span class="line">    <span class="keyword">while</span>(que-&gt;head &lt; que-&gt;tail &amp;&amp; que-&gt;q[(que-&gt;tail<span class="number">-1</span>)%k] &lt; value)&#123;</span><br><span class="line">        que-&gt;tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当tail超出k之后, 就会去覆盖队列的最开头</span></span><br><span class="line">    que-&gt;q[que-&gt;tail%k] = value;</span><br><span class="line">    que-&gt;tail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为队列是从大到小的, 所以队头就是最大的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueFront</span><span class="params">(MyQueue* que, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que-&gt;q[que-&gt;head%k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">maxSlidingWindow</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    MyQueue* que = (MyQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    <span class="comment">// 只维护一个大小为k的队列, 通过head%k跟tail%k来查找值</span></span><br><span class="line">    que-&gt;q = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*k);</span><br><span class="line">    que-&gt;head = <span class="number">0</span>;</span><br><span class="line">    que-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组长度减去k再加1就是输出数组的长度了</span></span><br><span class="line">    *returnSize = numsSize-k+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(numsSize));</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先把前k个数字添加进队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        QueuePush(que, nums[i], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res记录第一个窗口的最大值</span></span><br><span class="line">    res[top++] = QueueFront(que, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;numsSize; i++)&#123;</span><br><span class="line">        <span class="comment">// 对窗口最左边要移除的元素进行pop</span></span><br><span class="line">        QueuePop(que, nums[i-k], k);</span><br><span class="line">        <span class="comment">// 对窗口最右边要进来的元素进行push</span></span><br><span class="line">        QueuePush(que, nums[i], k);</span><br><span class="line">        <span class="comment">// res记录当前窗口的最大值</span></span><br><span class="line">        res[top++] = QueueFront(que, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(que-&gt;q);</span><br><span class="line">    <span class="built_in">free</span>(que);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347.前 K 个高频元素</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题其实就是在问最大的 k 个数, 频率遍历一遍就可以得到了, 因为了解具体的做法, 所以直接偷懒用 Counter 函数了.<br>Python 里面其实是有优先级队列 heapq 的, 代码随想录网站上的也是这个方法. 但是我想具体了解一下堆的写法, 所以找了个<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/solutions/19328/python-dui-pai-xu-by-xxinjiee/">手写小顶堆的题解</a></p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">arr, root, k</span>):</span><br><span class="line">            <span class="comment"># 下沉log(k), 如果新的根节点&gt;子节点就一直下沉</span></span><br><span class="line">            <span class="comment"># 这里的根节点就是新节点, 因为旧的根节点是最小的, 已经被踢出去了</span></span><br><span class="line">            val = arr[root]</span><br><span class="line">            <span class="keyword">while</span> root&lt;&lt;<span class="number">1</span> &lt;k:</span><br><span class="line">                child = root&lt;&lt;<span class="number">1</span>     <span class="comment"># root&lt;&lt;1是左孩子, root&lt;&lt;1|1是右孩子</span></span><br><span class="line">                <span class="comment"># 选择左右孩子中比较小的那个点</span></span><br><span class="line">                <span class="keyword">if</span> child|<span class="number">1</span> &lt; k <span class="keyword">and</span> arr[child|<span class="number">1</span>][<span class="number">1</span>] &lt; arr[child][<span class="number">1</span>]:</span><br><span class="line">                    child |= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果子节点&lt;新节点, 把小的数往上提</span></span><br><span class="line">                <span class="keyword">if</span> arr[child][<span class="number">1</span>] &lt; val[<span class="number">1</span>]:</span><br><span class="line">                    arr[root] = arr[child]</span><br><span class="line">                    root = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span>   <span class="comment"># 如果子节点比新节点大, 说明找到位置了</span></span><br><span class="line">            <span class="comment"># 将val插入到正确的位置上</span></span><br><span class="line">            arr[root] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">arr, child</span>):</span><br><span class="line">            <span class="comment"># 上浮log(k), 如果新加入的节点&lt;父节点就一直上浮</span></span><br><span class="line">            val = arr[child]</span><br><span class="line">            <span class="comment"># 如果child不是根节点, 并且val比child的父节点小, 交换</span></span><br><span class="line">            <span class="keyword">while</span> child&gt;&gt;<span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> val[<span class="number">1</span>] &lt; arr[child&gt;&gt;<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                arr[child] = arr[child&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                child &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="comment"># val放到合适的位置上</span></span><br><span class="line">            arr[child] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 直接调用Counter函数获取频率map</span></span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        stat = <span class="built_in">list</span>(count.items())</span><br><span class="line">        <span class="comment"># 这里需要一个虚拟的根节点, 目的是让真正根节点的值为1</span></span><br><span class="line">        <span class="comment"># 因为0&gt;&gt;1还是0, 需要根节点为1才能正常的使用位运算找子节点</span></span><br><span class="line">        heap = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建规模为k+1的堆, 新元素加入堆尾, 上浮</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            heap.append(stat[i])</span><br><span class="line">            sift_up(heap, <span class="built_in">len</span>(heap)-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 维护规模为k+1的堆, 如果新元素大于堆顶, 入堆, 并下沉</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(stat)):</span><br><span class="line">            <span class="keyword">if</span> stat[i][<span class="number">1</span>] &gt; heap[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                heap[<span class="number">1</span>] = stat[i]</span><br><span class="line">                sift_down(heap, <span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> heap[<span class="number">1</span>:]]</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nlogk)<br>空间复杂度: O(k)</p>
<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define the hash table structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125; HashEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> HashEntry* HashEntryPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the pair structure for heap elements</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">&#125; Pair;</span><br><span class="line"></span><br><span class="line">Pair* frequencyHeap;</span><br><span class="line"><span class="type">int</span> heapSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap two pairs</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapPairs</span><span class="params">(Pair* a, Pair* b)</span> &#123;</span><br><span class="line">    Pair temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compare two pairs based on their second value</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">comparePairs</span><span class="params">(Pair* a, Pair* b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;second &lt; b-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the top element of the heap</span></span><br><span class="line">Pair <span class="title function_">getTop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> frequencyHeap[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push an element into the heap</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushToHeap</span><span class="params">(HashEntryPtr entry)</span> &#123;</span><br><span class="line">    frequencyHeap[++heapSize].first = entry-&gt;key;</span><br><span class="line">    frequencyHeap[heapSize].second = entry-&gt;value;</span><br><span class="line">    <span class="type">int</span> position = heapSize, parent;</span><br><span class="line">    <span class="keyword">while</span> (position &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        parent = position &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (comparePairs(&amp;frequencyHeap[parent], &amp;frequencyHeap[position])) <span class="keyword">return</span>;</span><br><span class="line">        swapPairs(&amp;frequencyHeap[position], &amp;frequencyHeap[parent]);</span><br><span class="line">        position = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop the top element from the heap</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">popFromHeap</span><span class="params">()</span> &#123;</span><br><span class="line">    frequencyHeap[<span class="number">1</span>] = frequencyHeap[heapSize--];</span><br><span class="line">    <span class="type">int</span> position = <span class="number">1</span>, child;</span><br><span class="line">    <span class="keyword">while</span> ((position &lt;&lt; <span class="number">1</span>) &lt;= heapSize) &#123;</span><br><span class="line">        child = position &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (child &lt; heapSize &amp;&amp; comparePairs(&amp;frequencyHeap[child + <span class="number">1</span>], &amp;frequencyHeap[child])) child++;</span><br><span class="line">        <span class="keyword">if</span> (comparePairs(&amp;frequencyHeap[position], &amp;frequencyHeap[child])) <span class="keyword">return</span>;</span><br><span class="line">        swapPairs(&amp;frequencyHeap[position], &amp;frequencyHeap[child]);</span><br><span class="line">        position = child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the top K frequent elements</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">topKFrequent</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    HashEntryPtr hashHead = <span class="literal">NULL</span>;</span><br><span class="line">    HashEntryPtr currentEntry = <span class="literal">NULL</span>, tempEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        HASH_FIND_INT(hashHead, &amp;nums[i], currentEntry);</span><br><span class="line">        <span class="keyword">if</span> (currentEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            currentEntry = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashEntry));</span><br><span class="line">            currentEntry-&gt;key = nums[i];</span><br><span class="line">            currentEntry-&gt;value = <span class="number">1</span>;</span><br><span class="line">            HASH_ADD_INT(hashHead, key, currentEntry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentEntry-&gt;value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frequencyHeap = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pair) * (k + <span class="number">1</span>));</span><br><span class="line">    heapSize = <span class="number">0</span>;</span><br><span class="line">    HASH_ITER(hh, hashHead, currentEntry, tempEntry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heapSize &lt; k) &#123;</span><br><span class="line">            pushToHeap(currentEntry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pair topPair = getTop();</span><br><span class="line">            <span class="keyword">if</span> (topPair.second &lt; currentEntry-&gt;value) &#123;</span><br><span class="line">                popFromHeap();</span><br><span class="line">                pushToHeap(currentEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = k;</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        Pair topPair = getTop();</span><br><span class="line">        popFromHeap();</span><br><span class="line">        result[i] = topPair.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free allocated memory</span></span><br><span class="line">    HASH_ITER(hh, hashHead, currentEntry, tempEntry) &#123;</span><br><span class="line">        HASH_DEL(hashHead, currentEntry);</span><br><span class="line">        <span class="built_in">free</span>(currentEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(frequencyHeap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C 代码实在太难了, 找 gpt 要了一版, 大概能看懂是做什么, 等周末再仔细研究一下</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/10/03/day11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/10/03/day11/" class="post-title-link" itemprop="url">Day11：20. 有效的括号 1047. 删除字符串中的所有相邻重复项 150. 逆波兰表达式求值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-03 16:46:55 / 修改时间：22:29:42" itemprop="dateCreated datePublished" datetime="2023-10-03T16:46:55+11:00">2023-10-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遇到左括号则进栈, 遇到右括号则判断与栈中最后一个左括号是否匹配, 栈为空或者匹配不上就说明字符串无效. 最后再判断栈是否为空, 不为空说明还有左括号没有匹配右括号</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># 左右括号匹配的字典, 会增加空间, 但是可以减少写if</span></span><br><span class="line">        bracket = &#123;<span class="string">&quot;)&quot;</span>:<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&#125;&quot;</span>:<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;]&quot;</span>:<span class="string">&quot;[&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 左括号进栈</span></span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&quot;(&quot;</span> <span class="keyword">or</span> ch == <span class="string">&quot;&#123;&quot;</span> <span class="keyword">or</span> ch == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="comment"># 右括号的话, 从栈中弹出最后一个元素, 如果不是对应的左括号则匹配失败</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> bracket.keys():</span><br><span class="line">                <span class="comment"># 如果栈为空也匹配失败</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> stack.pop() != bracket[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果栈不为空, 说明左括号多了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始化栈</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span>* <span class="built_in">stack</span> = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*len);</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果是左括号, 则进栈</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span> || s[i]==<span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top++] = s[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;        <span class="comment">// 对于每种右括号都写一个判断, 是否跟栈顶的左括号匹配, 也可以单独写一个匹配函数</span></span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">0</span> || <span class="built_in">stack</span>[--top]!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">0</span> || <span class="built_in">stack</span>[--top]!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">0</span> || <span class="built_in">stack</span>[--top]!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>队列模拟栈比较简单, 一个队列就能完成, 添加元素的时候正常添加就行, 然后需要弹出元素的时候, 把整个队列除了最后一个元素以外, 全部都弹出重新添加一遍, 这样就可以把队列尾的元素弹出来了</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 类似括号匹配算法, 把字母当括号看就行了</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == ch:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span>* res = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*len+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(top&gt;<span class="number">0</span> &amp;&amp; s[i]==res[top<span class="number">-1</span>])&#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[top++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符结束符&#x27;\0&#x27;</span></span><br><span class="line">    res[top] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>逆波兰表达式就是后缀计算, 每次遇到计算符的时候, 都对前两个数进行操作. 同样利用栈, 遇到数字就入栈, 遇到计算符就把前两个数拿出来, 计算后再入栈. 最后返回栈内剩下的元素就是计算结果了</p>
<h3 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="comment"># 如果是数字, 入栈</span></span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>):</span><br><span class="line">                stack.append(item)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果是操作符, 拿出两个数字, 进行操作后将结果入栈</span></span><br><span class="line">                b = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                a = <span class="built_in">int</span>(stack.pop())</span><br><span class="line">                <span class="keyword">if</span> item == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    c = a + b</span><br><span class="line">                <span class="keyword">elif</span> item == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    c = a * b</span><br><span class="line">                <span class="keyword">elif</span> item == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    c = a - b</span><br><span class="line">                <span class="keyword">elif</span> item == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    c = a / b</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack.pop())</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(<span class="type">char</span> ** tokens, <span class="type">int</span> tokensSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[tokensSize];</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tokensSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;+&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;*&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">stack</span>[--top];</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">stack</span>[--top];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;+&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top++] = a + b;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;*&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top++] = a * b;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top++] = b - a;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tokens[i], <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top++] = b / a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top++] = atoi(tokens[i]); <span class="comment">// Convert string to integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/10/03/day10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/10/03/day10/" class="post-title-link" itemprop="url">Day10：232.用栈实现队列 225. 用队列实现栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-03 01:15:48 / 修改时间：02:07:28" itemprop="dateCreated datePublished" datetime="2023-10-03T01:15:48+11:00">2023-10-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232.用栈实现队列</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈是先进后出, 队列是先进先出. 可以用两个栈来模拟队列, 每次 push 的时候就正常的往入栈<code>stack_in</code>里面塞就行, 出队列的时候比较麻烦, 需要先把入栈中的所有元素都添加到出栈中, 相当于把元素倒过来了, 然后再从出栈里面拿<br>注意点: 如果出栈不为空, 就继续从出栈弹出就行, 直到出栈为空才需要从入栈添加, 而且每次都需要把入栈中的所有元素都添加进来.<br>如果两个栈的大小分别为 m 和 n(m&gt;n), 那么队列长度最大为 2n+1, 出栈可以存 n 个, 入栈存 n+1 个, 出栈先出来 n 个, 入栈进去 n 个, 然后把最后的 2n+1 个弹出来</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化两个栈, 入栈和出栈</span></span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 进入队列时直接进入入栈就行</span></span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果两个栈都是空的, 就说明队列是空的, 返回None</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果出栈还有元素, 直接从出栈弹出</span></span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="comment"># 如果出栈空了, 将入栈的所有元素都添加到出栈, 然后再从出栈弹出</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">            self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 看一眼ans, 然后再添加回出栈</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 只有入栈跟出栈都是空的, 才说明队列是空的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：push 和 empty 是 O(1), pop 和 peek 是 O(n)<br>空间复杂度：O(n+m)</p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> stackInTop, stackOutTop;</span><br><span class="line">    <span class="type">int</span> stackIn[<span class="number">100</span>], stackOut[<span class="number">100</span>];</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyQueue* <span class="title function_">myQueueCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyQueue* <span class="built_in">queue</span> = (MyQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;stackInTop = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;stackOutTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myQueuePush</span><span class="params">(MyQueue* obj, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    obj-&gt;stackIn[obj-&gt;stackInTop++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;stackInTop == <span class="number">0</span> &amp;&amp; obj-&gt;stackOutTop == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePop</span><span class="params">(MyQueue* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(myQueueEmpty(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制栈顶指针, 减少对内存的访问</span></span><br><span class="line">    <span class="type">int</span> stackInTop = obj-&gt;stackInTop;</span><br><span class="line">    <span class="type">int</span> stackOutTop = obj-&gt;stackOutTop;</span><br><span class="line">    <span class="keyword">if</span>(stackOutTop != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;stackOut[--obj-&gt;stackOutTop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stackInTop&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        obj-&gt;stackOut[stackOutTop++] = obj-&gt;stackIn[--stackInTop];</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;stackOutTop = stackOutTop;</span><br><span class="line">    obj-&gt;stackInTop = stackInTop;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;stackOut[--obj-&gt;stackOutTop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePeek</span><span class="params">(MyQueue* obj)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = myQueuePop(obj);</span><br><span class="line">    obj-&gt;stackOut[obj-&gt;stackOutTop++] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myQueueFree</span><span class="params">(MyQueue* obj)</span> &#123;</span><br><span class="line">    obj-&gt;stackInTop = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;stackOutTop = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = myQueueCreate();</span></span><br><span class="line"><span class="comment"> * myQueuePush(obj, x);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * int param_2 = myQueuePop(obj);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * int param_3 = myQueuePeek(obj);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * bool param_4 = myQueueEmpty(obj);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>队列模拟栈比较简单, 一个队列就能完成, 添加元素的时候正常添加就行, 然后需要弹出元素的时候, 把整个队列除了最后一个元素以外, 全部都弹出重新添加一遍, 这样就可以把队列尾的元素弹出来了</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue)-<span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.popleft())</span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tmp = self.pop()</span><br><span class="line">        self.queue.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/10/01/day9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/10/01/day9/" class="post-title-link" itemprop="url">Day9：28. 实现 strStr() 459.重复的子字符串 字符串总结  双指针回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-01 16:16:46" itemprop="dateCreated datePublished" datetime="2023-10-01T16:16:46+11:00">2023-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-03 01:15:46" itemprop="dateModified" datetime="2023-10-03T01:15:46+11:00">2023-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题是从文本串中找模式串, 如果用暴力的话就是O(n^2). 可以用KMP算法, 具体做法就是找到最长相等前后缀, 假如模式串为”aabaac”, 那么当文本串中的”aabaab”匹配到第六位b跟c不同的时候, 不需要回到模式串最开头位置重新开始比较, 从NEXT数组中可以得知第五位的”a”的最长相等前后缀是3, 所以可以回到模式串的第三个位置然后继续往后比较. 因为此时我已经知道了文本串中后三位的”aab”跟模式串的前三位是相同的了.<br>KMP算法中重要的点就是NEXT数组, 简单来说, 就是记录模式串中每个位置的最长相等前后缀, 并且在getNEXT函数里面就可以应用到<code>j=next[j]</code>来进行回退了</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">s</span>):</span><br><span class="line">            <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">            <span class="built_in">next</span>[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">            j = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment"># 如果不匹配, 一路回退找到最长匹配时候的j, 最多倒回到-1</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j+<span class="number">1</span>]:</span><br><span class="line">                    j = <span class="built_in">next</span>[j]</span><br><span class="line">                <span class="comment"># 如果匹配, 最长相等前后缀的值加一</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j+<span class="number">1</span>]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="built_in">next</span>[i] = j</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">next</span> = getNext(needle)</span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="comment"># 不匹配的话, 倒回去找最长匹配的j</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j+<span class="number">1</span>]:</span><br><span class="line">                j = <span class="built_in">next</span>[j]</span><br><span class="line">            <span class="comment"># 如果匹配的话, 匹配长度加一</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j+<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 因为j初始是-1, 所以只要到needle长度-1就说明匹配上了</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle)-<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 这个时候的i是匹配单词的最后一个字母位置, 需要返回第一个字母</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="built_in">len</span>(needle) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)<br>空间复杂度：O(m) next数组的长度等于模式串的长度</p>
<hr>
<h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a>459. 重复的子字符串</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题除了暴力解法以外, 有一种做法是<code>t = s + s</code>, 然后判断<code>s in t[1:-1]</code>, 也就是说如果是重复子串, 拼接之后还会有一个自己.<br>更进一步的做法还是利用KMP算法, 如注释</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j+<span class="number">1</span>]:</span><br><span class="line">                j = <span class="built_in">next</span>[j]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j+<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i] = j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * n</span><br><span class="line">        self.getNext(<span class="built_in">next</span>, s)</span><br><span class="line">        <span class="comment"># 假如s是重复子串, 那么s = n*x, x是最小子串</span></span><br><span class="line">        <span class="comment"># 那么最长相等前后缀为m*x, m = n-1</span></span><br><span class="line">        <span class="comment"># len(n*x) % len((n-m)*x) = 0</span></span><br><span class="line">        <span class="comment"># 最长相等前后缀m为next[n-1]+1, 因为最开始j设为-1了所以要+1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">next</span>[n-<span class="number">1</span>] != -<span class="number">1</span> <span class="keyword">and</span> n%(n-(<span class="built_in">next</span>[n-<span class="number">1</span>]+<span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/27/day8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/27/day8/" class="post-title-link" itemprop="url">Day8： 344.反转字符串 541. 反转字符串II 剑指Offer 05.替换空格 151.翻转字符串里的单词 剑指Offer58-II.左旋转字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-27 21:47:25" itemprop="dateCreated datePublished" datetime="2023-09-27T21:47:25+10:00">2023-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-29 16:20:10" itemprop="dateModified" datetime="2023-09-29T16:20:10+10:00">2023-09-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344.反转字符串</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Python 可以直接调用 reverse，其他语言也有 API 可以调用，但是还是得自己实现一下比较好。主要就是利用双指针，一个从头开始一个从尾开始，一路交换头尾。</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> sSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = sSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        tmp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = tmp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a>541. 反转字符串 II</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题本身不难, 就是在上一题的基础上, 多判断一下只翻转其中一部分. 比较巧妙的点在于利用列表切片后面超了也只会到末尾的性质, 可以少写一个判断.</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_substring</span>(<span class="params">text</span>):    <span class="comment"># 反转子字符串</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(text) - <span class="number">1</span>  <span class="comment"># 两个指针指向头和尾</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                text[left], text[right] = text[right], text[left]   <span class="comment"># 调转头尾</span></span><br><span class="line">                left += <span class="number">1</span>   <span class="comment"># 往中间缩</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), k*<span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 利用切片的性质, 如果cur+k超过了s的长度,也只会切到最后一个字符</span></span><br><span class="line">            res[cur: cur+k] = reverse_substring(res[cur:cur+k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">reverseStr</span><span class="params">(<span class="type">char</span> * s, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i+=(<span class="number">2</span>*k))&#123;</span><br><span class="line">        k = i+k &gt; len ? len-i : k;  <span class="comment">// 如果i+k超过字符串末尾, 那就把剩余字符全部反转</span></span><br><span class="line">        <span class="comment">// 两个指针指向头和尾</span></span><br><span class="line">        <span class="type">int</span> left = i;</span><br><span class="line">        <span class="type">int</span> right = i + k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 交换头尾</span></span><br><span class="line">            <span class="type">char</span> tmp = s[left];</span><br><span class="line">            s[left++] = s[right];</span><br><span class="line">            s[right--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(1)或 O(n), 取决于所用语言是否允许修改字符串</p>
<hr>
<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05.替换空格"></a>剑指 Offer 05.替换空格</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tqId=1374738&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">剑指 Offer 05.替换空格</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题直接用 python 的 replace 一步就解决了, 当然实际考验的是内存扩展, 因为从空格的一个字符变成’%20’的三个字符</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span>: stack.append(<span class="string">&#x27;%20&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>: stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s string字符串</span></span><br><span class="line"><span class="comment"> * @return string字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">replaceSpace</span><span class="params">(<span class="type">char</span>* s )</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">// 统计空格数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为新数组分配空间</span></span><br><span class="line">    <span class="type">int</span> newlen = len + count * <span class="number">2</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * newlen + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 填充新数组并替换空格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>, j=newlen<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            result[j] = s[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            result[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            result[j] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result[newlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题当然也可以用 split 然后反转. 但是还有一种办法就是先反转整个字符串, 然后再反转每个单词.</p>
<h3 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = s.strip()</span><br><span class="line">        i = j = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 找到第一个空格</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;=<span class="number">0</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>: i-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 这个时候i是空格，i+1是单词的头，j是单词的尾</span></span><br><span class="line">            res.append(s[i+<span class="number">1</span>:j+<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 跳过中间的所有空格</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] == <span class="string">&#x27; &#x27;</span>: i-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 把j更新为下一个单词的尾巴</span></span><br><span class="line">            j = i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h3 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start, j=end; i&lt;j; ++i, --j)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">removeExtraSpace</span><span class="params">(<span class="type">char</span>* s)</span>&#123;     <span class="comment">// 类似移除元素</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;  <span class="comment">// 指向字符串开头的指针</span></span><br><span class="line">    <span class="type">int</span> end = <span class="built_in">strlen</span>(s) - <span class="number">1</span>;    <span class="comment">// 指向字符串结尾的指针</span></span><br><span class="line">    <span class="keyword">while</span>(s[start] == <span class="string">&#x27; &#x27;</span>) start++;     <span class="comment">// 去除字符串开头的空格</span></span><br><span class="line">    <span class="keyword">while</span>(s[end] == <span class="string">&#x27; &#x27;</span>) end--;     <span class="comment">// 去除字符串结尾的空格</span></span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;       <span class="comment">// 指向新字符串下一个写入位置的指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=end; i++)&#123;      <span class="comment">// 遍历整个字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;       <span class="comment">// 如果当前字符串为空格,并且下一个字符串也是空格,则跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[slow] = s[i];     <span class="comment">// 否则, 将当前字符串复制到新字符串的slow位置</span></span><br><span class="line">        slow++;     <span class="comment">// 将slow指针向后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[slow] = <span class="string">&#x27;\0&#x27;</span>;     <span class="comment">// 在新字符串的末尾添加一个空字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="comment">// 先翻转整个字符串, 把&quot;the sky is blue&quot;翻转为&quot;eulb si yks eht&quot;</span></span><br><span class="line">    <span class="comment">// 然后翻转每个单词, 变成&quot;blue is sky the&quot;</span></span><br><span class="line">    removeExtraSpace(s);    <span class="comment">// 先删除字符串两端和中间多余的空格</span></span><br><span class="line">    reverse(s, <span class="number">0</span>, <span class="built_in">strlen</span>(s) - <span class="number">1</span>);   <span class="comment">// 翻转整个字符串</span></span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">// 指向每个单词的开头位置的指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="built_in">strlen</span>(s); i++)&#123;  <span class="comment">// 遍历整个字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span> || s[i] == <span class="string">&#x27;\0&#x27;</span>)&#123;    <span class="comment">// 如果当前字符是空格或空字符,说明一个单词结束了</span></span><br><span class="line">            reverse(s, slow, i<span class="number">-1</span>);  <span class="comment">// 翻转单词</span></span><br><span class="line">            slow = i+<span class="number">1</span>; <span class="comment">// 将slow指向下一个单词的开头位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;   <span class="comment">// 返回处理后的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="剑指-Offer58-II-左旋转字符串"><a href="#剑指-Offer58-II-左旋转字符串" class="headerlink" title="剑指 Offer58-II.左旋转字符串"></a>剑指 Offer58-II.左旋转字符串</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题还是利用多次反转,想要把前 n 个旋转到后面去, 可以把前 n 个先反转, 然后反转 n 之后的, 最后反转整个字符串</p>
<h3 id="Python-代码-3"><a href="#Python-代码-3" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @param str string字符串</span></span><br><span class="line"><span class="comment"># @param n int整型</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, s: <span class="type">List</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            self.swap(s, start, end)</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self, s, start, end</span>):</span><br><span class="line">        tmp = s[start]</span><br><span class="line">        s[start] = s[end]</span><br><span class="line">        s[end] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LeftRotateString</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        n = n % <span class="built_in">len</span>(s)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        self.reverse(s, n, <span class="built_in">len</span>(s)-<span class="number">1</span>)</span><br><span class="line">        self.reverse(s, <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/26/day7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/26/day7/" class="post-title-link" itemprop="url">Day7： 454.四数相加II 383. 赎金信 15. 三数之和 18. 四数之和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-26 19:38:07" itemprop="dateCreated datePublished" datetime="2023-09-26T19:38:07+10:00">2023-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-27 21:48:06" itemprop="dateModified" datetime="2023-09-27T21:48:06+10:00">2023-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454.四数相加 II"></a>454.四数相加 II</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加 II</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>类似二数相加，二数之后可以用哈希来让 O(n^2)变成两个 O(n)，这题是让 O(n^4)变成两个 O(n^2)</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">                num = nums1[i] + nums2[j]</span><br><span class="line">                cnt[num] = cnt.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums3)):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums4)):</span><br><span class="line">                num = nums3[k] + nums4[l]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>-num <span class="keyword">in</span> cnt.keys():</span><br><span class="line">                    res += cnt[-num]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span>* nums3, <span class="type">int</span> nums3Size, <span class="type">int</span>* nums4, <span class="type">int</span> nums4Size)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">hashtable</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1Size; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums2Size; ++j)&#123;</span><br><span class="line">            <span class="type">int</span> ikey = nums1[i] + nums2[j];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            <span class="comment">// 在hashtable中寻找整数键ikey的地址，将结果存到tmp中</span></span><br><span class="line">            HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">            <span class="comment">// 如果tmp是空的，说明没找到</span></span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hashTable));</span><br><span class="line">                tmp-&gt;key = ikey, tmp-&gt;val = <span class="number">1</span>;</span><br><span class="line">                HASH_ADD_INT(hashtable, key, tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;nums3Size; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>; l&lt;nums4Size; l++)&#123;</span><br><span class="line">            <span class="type">int</span> ikey = -nums3[k] - nums4[l];</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hashTable</span>* <span class="title">tmp</span>;</span></span><br><span class="line">            HASH_FIND_INT(hashtable, &amp;ikey, tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                ans += tmp-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<hr>
<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信</a></p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cnt_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> magazine:</span><br><span class="line">            cnt_dict[m] = cnt_dict.get(m, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="comment"># 如果赎金信中的单词，在杂志中没有或者数量不够，就返回Flase</span></span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> cnt_dict <span class="keyword">or</span> cnt_dict[r] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cnt_dict[r] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canConstruct</span><span class="params">(<span class="type">char</span> * ransomNote, <span class="type">char</span> * magazine)</span>&#123;</span><br><span class="line">    <span class="type">int</span> maga_num[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(magazine); ++i)&#123;</span><br><span class="line">        maga_num[magazine[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(ransomNote); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maga_num[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maga_num[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题因为答案要求去重，如果用哈希的话，剪枝要考虑的情况很多，用双指针更好。</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left, right = i+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[left] + nums[right] + nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[left] + nums[right] + nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]: right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]==nums[left+<span class="number">1</span>]: left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n^2)<br>空间复杂度: O(1)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">int</span>*)ptr1) &gt; *((<span class="type">int</span>*)ptr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>&#123;</span><br><span class="line">    <span class="type">int</span>** ans = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * <span class="number">18000</span>);</span><br><span class="line">    <span class="type">int</span> ansTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] + nums[left] + nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right] + nums[left] + nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">3</span>);</span><br><span class="line">                arr[<span class="number">0</span>] = nums[i];</span><br><span class="line">                arr[<span class="number">1</span>] = nums[left];</span><br><span class="line">                arr[<span class="number">2</span>] = nums[right];</span><br><span class="line">                ans[ansTop++] = arr;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ansTop;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * ansTop);</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">for</span>(z=<span class="number">0</span>; z&lt;ansTop; ++z)&#123;</span><br><span class="line">        (*returnColumnSizes)[z] = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">18. 四数之和</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>跟三数之和一样，只是多加一层循环，也就是说双指针法只能去掉一层循环，比如 O(n^4)变成 O(n^3)。同时要额外考虑去重的情况。</p>
<h3 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; target <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left, right = j+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums[left] + nums[right] + nums[i] + nums[j] &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[left] + nums[right] + nums[i] + nums[j] &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]: right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left]==nums[left+<span class="number">1</span>]: left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n^3)<br>空间复杂度: O(1)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/25/day6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/25/day6/" class="post-title-link" itemprop="url">Day6： 242.有效的字母异位词 349. 两个数组的交集 202. 快乐数 1. 两数之和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-25 11:34:17" itemprop="dateCreated datePublished" datetime="2023-09-25T11:34:17+10:00">2023-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-27 21:50:08" itemprop="dateModified" datetime="2023-09-27T21:50:08+10:00">2023-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242.有效的字母异位词</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题如果用 Python 可以用字典或者调用 Counter，但是毕竟是学哈希表，还是用数组更好一些</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 初始化哈希表，26个字母所以数组长度为26</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 如果在s中，该字母对应的位置+1</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            count[<span class="built_in">ord</span>(ch)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果在t中，该字母对应的位置-1</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> t:</span><br><span class="line">            count[<span class="built_in">ord</span>(ch)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果全是0，说明s跟t各字母数量相同</span></span><br><span class="line">        <span class="keyword">return</span> count == [<span class="number">0</span>] * <span class="number">26</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    <span class="comment">// 为了让head前面也能有一个pre，定义一个虚拟头结点，同时也方便定位头</span></span><br><span class="line">    ListNode* dummy_head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummy_head-&gt;next = head;</span><br><span class="line">    ListNode* pre = dummy_head;</span><br><span class="line">    <span class="comment">// 如果pre后面只有一个结点的话，那也没必要做交换</span></span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next)&#123;</span><br><span class="line">        <span class="comment">// cur和next是要交换的两个节点，先让pre指向next，然后cur指向next的next，然后next指向cur，完成交换</span></span><br><span class="line">        ListNode* cur = pre-&gt;next;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a><br>基本的增删改查操作，主要是利用双指针来找到倒数第 n 个节点，也就是两个指针之间固定差 n+1，这样一个到顶了，另一个就是倒 n+1 了</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 不用虚拟头结点也一样，但是习惯用了</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre = dummy_head</span><br><span class="line">        tail = head</span><br><span class="line">        <span class="comment"># 让tail先走n步，这样pre跟tail之间就差了n+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当tail到达最后的空节点时，pre刚好是倒n+1个</span></span><br><span class="line">        <span class="keyword">while</span> tail:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 删除pre的下一个节点，也就是倒数第n个节点</span></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span> * s, <span class="type">char</span> * t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++)&#123;</span><br><span class="line">        count[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        count[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在 Python 中其实可以直接用<code>set(nums1)&amp;set(nums2)</code>来求交集，但是没有意义，还是要自己写一个哈希表出来比较好。</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 定义一个哈希表</span></span><br><span class="line">        <span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 将第一个数组的元素放入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hash</span>.get(n):</span><br><span class="line">                <span class="built_in">hash</span>[n] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 遍历第二个数组，将哈希表中有的添加到结果中</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hash</span>.get(n):</span><br><span class="line">                res.append(n)</span><br><span class="line">                <span class="comment"># 将hash值变成0，防止数组2中的元素重复添加</span></span><br><span class="line">                <span class="built_in">hash</span>[n] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Hash[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> lenSize = nums1Size &lt; nums2Size ? nums1Size : nums2Size;</span><br><span class="line">    <span class="type">int</span>* res = (<span class="type">int</span>*)<span class="built_in">calloc</span>(lenSize, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> resIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1Size; i++)&#123;</span><br><span class="line">        Hash[nums1[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2Size; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Hash[nums2[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            res[resIndex++] = nums2[i];</span><br><span class="line">            Hash[nums2[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = resIndex;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题题目限制了 0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 所以可以用数组，但是如果题目没有限制的话，那么用 set 会是个更好的办法。下面放一个 C 实现字典的代码，Chatgpt 给的，也能 ac：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_SIZE 1000</span></span><br><span class="line"><span class="comment">// 定义哈希实例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; HashEntry;</span><br><span class="line"><span class="comment">// 哈希表中有1000个桶</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HashEntry *table[HASH_SIZE];</span><br><span class="line">&#125; HashMap;</span><br><span class="line"></span><br><span class="line">HashMap* <span class="title function_">createHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap* hashMap = (HashMap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashMap));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) &#123;</span><br><span class="line">        hashMap-&gt;table[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(HashMap* hashMap, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key % HASH_SIZE;</span><br><span class="line">    <span class="keyword">while</span> (hashMap-&gt;table[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % HASH_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    HashEntry* entry = (HashEntry*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashEntry));</span><br><span class="line">    entry-&gt;key = key;</span><br><span class="line">    entry-&gt;value = value;</span><br><span class="line">    hashMap-&gt;table[index] = entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get</span><span class="params">(HashMap* hashMap, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = key % HASH_SIZE;</span><br><span class="line">    <span class="keyword">while</span> (hashMap-&gt;table[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap-&gt;table[index]-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(hashMap-&gt;table[index]-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        index = (index + <span class="number">1</span>) % HASH_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeHashMap</span><span class="params">(HashMap* hashMap)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HASH_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap-&gt;table[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(hashMap-&gt;table[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(hashMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    HashMap* hashMap = createHashMap();</span><br><span class="line">    <span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(HASH_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1Size; i++) &#123;</span><br><span class="line">        put(hashMap, nums1[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2Size; i++) &#123;</span><br><span class="line">        <span class="type">int</span>* value = get(hashMap, nums2[i]);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">NULL</span> &amp;&amp; *value == <span class="number">1</span>) &#123;</span><br><span class="line">            result[resultSize++] = nums2[i];</span><br><span class="line">            *get(hashMap, nums2[i]) = <span class="number">0</span>; <span class="comment">// 防止重复添加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = resultSize;</span><br><span class="line">    freeHashMap(hashMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>主要使用一个哈希表记录见过的数，这样出现循环了立马就能知道了</p>
<h3 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="comment"># 每次加个位数的平方，然后把n去掉个位数</span></span><br><span class="line">                <span class="built_in">sum</span> += (n%<span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">                n //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果出现了重复的n，说明有循环，也就是始终变不到1</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="built_in">sum</span> = getSum(n)</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(logn)<br>空间复杂度: O(logn)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        sum = sum + (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">// 计算数组最少多长可以满足所有情况，假如n是最大的2^31-1，也就是10位数</span></span><br><span class="line">    <span class="comment">// 第一轮最大，n为1后面9个9，计算sum: 1+9*9*9 = 730</span></span><br><span class="line">    <span class="comment">// 第二轮最大是n为699，sum: 36+81*2 = 198</span></span><br><span class="line">    <span class="comment">// 第三轮最大是n为99，sum: 81*2 = 162</span></span><br><span class="line">    <span class="comment">// 后面都小于等于162</span></span><br><span class="line">    <span class="type">uint8_t</span> seen[<span class="number">163</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = getSum(getSum(n));</span><br><span class="line">    n = sum;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">        sum = getSum(n);</span><br><span class="line">        <span class="keyword">if</span>(seen[sum]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seen[sum] = <span class="number">1</span>;</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>用一个字典存遍历过的数，然后每次询问这个字典对应的数是不是遍历过</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> <span class="built_in">hash</span>.keys():</span><br><span class="line">                <span class="keyword">return</span> [i, <span class="built_in">hash</span>[n]]</span><br><span class="line">            <span class="built_in">hash</span>[target-n] = i</span><br></pre></td></tr></table></figure>

<p>C 的哈希表要自己写太折磨了，照着代码打了一遍，大概理解意思，但是自己写估计还是写不出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    UT_hash_handle hh;</span><br><span class="line">&#125;<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>* hashMap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashMapAdd</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="built_in">map</span>* s;</span><br><span class="line">    HASH_FIND_INT(hashMap, &amp;key, s);</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        s = (<span class="built_in">map</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">        s -&gt; key = key;</span><br><span class="line">        HASH_ADD_INT(hashMap, key, s);</span><br><span class="line">    &#125;</span><br><span class="line">    s -&gt; value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>* <span class="title function_">hashMapFind</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="built_in">map</span>* s;</span><br><span class="line">    HASH_FIND_INT(hashMap, &amp;key, s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashMapCleanup</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">map</span>* cur, *tmp;</span><br><span class="line">    HASH_ITER(hh, hashMap, cur, tmp)&#123;</span><br><span class="line">        HASH_DEL(hashMap, cur);</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashPrint</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">map</span>* s;</span><br><span class="line">    <span class="keyword">for</span>(s = hashMap; s != <span class="literal">NULL</span>; s=(<span class="built_in">map</span>*)(s-&gt;hh.next))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key %d, value %d\n&quot;</span>, s -&gt; key, s -&gt; value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, *ans;</span><br><span class="line">    <span class="built_in">map</span>* hashMapRes;</span><br><span class="line">    hashMap = <span class="literal">NULL</span>;</span><br><span class="line">    ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashMapRes = hashMapFind(nums[i]))&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i;</span><br><span class="line">            ans[<span class="number">1</span>] = hashMapRes -&gt; value;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            hashMapCleanup();</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        hashMapAdd(target-nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/23/day4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/23/day4/" class="post-title-link" itemprop="url">Day4： 24. 两两交换链表中的节点  19.删除链表的倒数第N个节点  面试题 02.07. 链表相交  142.环形链表II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-23 16:16:33" itemprop="dateCreated datePublished" datetime="2023-09-23T16:16:33+10:00">2023-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-24 02:12:00" itemprop="dateModified" datetime="2023-09-24T02:12:00+10:00">2023-09-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数组结束了，今天开始链表相关的知识了，明天周末可以抽出时间来把数组章节做个总结</p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题还挺简单的，主要就是在脑子里过一遍交换的流程是什么样的，我为了方便想，定义了三个指针，cur 和 next 就是要交换的两个指针，pre 是它们前面的那个。<br>同时为了让 head 也可以同样操作，使用了 dummyhead 也就是虚拟头结点，这样 head 为 cur 的时候，也能有 pre 了。</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 有虚拟头结点其实不加这个判断也行</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 初始化虚拟头结点</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre = dummy_head</span><br><span class="line">        <span class="keyword">while</span> pre.<span class="built_in">next</span> != <span class="literal">None</span> <span class="keyword">and</span> pre.<span class="built_in">next</span>.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># pre指向next, cur的next是next的next，next指向cur，pre = cur</span></span><br><span class="line">            cur = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = cur</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">swapPairs</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    <span class="comment">// 为了让head前面也能有一个pre，定义一个虚拟头结点，同时也方便定位头</span></span><br><span class="line">    ListNode* dummy_head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummy_head-&gt;next = head;</span><br><span class="line">    ListNode* pre = dummy_head;</span><br><span class="line">    <span class="comment">// 如果pre后面只有一个结点的话，那也没必要做交换</span></span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next)&#123;</span><br><span class="line">        <span class="comment">// cur和next是要交换的两个节点，先让pre指向next，然后cur指向next的next，然后next指向cur，完成交换</span></span><br><span class="line">        ListNode* cur = pre-&gt;next;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = cur;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a><br>基本的增删改查操作，主要是利用双指针来找到倒数第 n 个节点，也就是两个指针之间固定差 n+1，这样一个到顶了，另一个就是倒 n+1 了</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 不用虚拟头结点也一样，但是习惯用了</span></span><br><span class="line">        dummy_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre = dummy_head</span><br><span class="line">        tail = head</span><br><span class="line">        <span class="comment"># 让tail先走n步，这样pre跟tail之间就差了n+1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当tail到达最后的空节点时，pre刚好是倒n+1个</span></span><br><span class="line">        <span class="keyword">while</span> tail:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 删除pre的下一个节点，也就是倒数第n个节点</span></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode* dummy_head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummy_head-&gt;next = head;</span><br><span class="line">    ListNode* pre = dummy_head;</span><br><span class="line">    ListNode* tail = head;</span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; tail)&#123;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tail)&#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* tmp = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = tmp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    head = dummy_head-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy_head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题首先先得到两个链表的长度，然后两个指针指向两个链表的头，移动长链表的指针，让两个指针到末尾的长度相同。这样的话，如果有交点，那么两个指针一起动的话，一定会在交点相遇。<br>因为从开头到交点的距离不一定相同，但是从末尾到交点的距离一定是相同的，因为他们到交点之后都是一起走到末尾的。<br>题解的双指针很精妙，代码更简洁，但是本质逻辑跟这个方法一样，写起来更难想，还是用这种分开的方法比较好做一些。</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="literal">None</span> <span class="keyword">or</span> headB == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a = ListNode(<span class="number">0</span>, headA)</span><br><span class="line">        b = ListNode(<span class="number">0</span>, headB)</span><br><span class="line">        size_a, size_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先遍历得到两个链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">            size_a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            b = b.<span class="built_in">next</span></span><br><span class="line">            size_b += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 把a, b回到链表头</span></span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        <span class="comment"># 让a变成长度更长的那个链表，用if判断写两种情况也行，这样更简洁</span></span><br><span class="line">        <span class="keyword">if</span> size_b &gt; size_a:</span><br><span class="line">            size_a, size_b = size_b, size_a</span><br><span class="line">            a, b = b, a</span><br><span class="line">        <span class="comment"># 让a, b到末尾的长度一样</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size_a-size_b):</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># a, b一起增加，如果有交点就会碰到</span></span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            <span class="keyword">if</span>(a == b):</span><br><span class="line">                <span class="keyword">return</span> a</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">            b = b.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n+m)<br>空间复杂度: O(1)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">a</span> =</span> headA;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">b</span> =</span> headB;</span><br><span class="line">    <span class="type">int</span> size_a = <span class="number">0</span>, size_b = <span class="number">0</span>, diff;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        size_a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        size_b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size_a&gt;size_b)&#123;</span><br><span class="line">        a = headA;</span><br><span class="line">        b = headB;</span><br><span class="line">        diff = size_a-size_b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        a = headB;</span><br><span class="line">        b = headA;</span><br><span class="line">        diff = size_b-size_a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(diff--)&#123;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>第三次做这道题了，还是忘记了。能想起来用快慢指针来找到第一次相遇的点，但是后面怎么找入口就忘记了，又重新理了一次思路，希望以后能记得吧。思路写注释里了，这边就不写了。</p>
<h3 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 定义快慢指针</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span>(fast <span class="keyword">and</span> fast.<span class="built_in">next</span>):</span><br><span class="line">            <span class="comment"># 慢指针每次走1，快指针走2</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果有环，一定会相遇，因为相对于慢指针，快指针相当于在环内走1</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                index1 = head</span><br><span class="line">                index2 = slow</span><br><span class="line">                <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                假设head到入口为x, 相遇时，入口到slow为y, slow到入口为z，也就是环长度为y+z</span></span><br><span class="line"><span class="string">                此时slow走了x+y, fast走了x+y+n(y+z)，n至少为1</span></span><br><span class="line"><span class="string">                那么(x+y)*2 = x+y+n(y+z), x+y = n(y+z)</span></span><br><span class="line"><span class="string">                因为要的是入口的位置，也就是x，所以让x到一边</span></span><br><span class="line"><span class="string">                x = (n-1)(y+z) + z</span></span><br><span class="line"><span class="string">                一个指针index1从head开始，一个指针index2从slow当前位置开始，</span></span><br><span class="line"><span class="string">                那么当index1走了x到达入口时，index2走了(n-1)(y+z)+z，</span></span><br><span class="line"><span class="string">                也就是说index2走了n-1圈之后，又走了z，而z就是slow到入口的距离。</span></span><br><span class="line"><span class="string">                所以此时index1跟index2会同时到达入口相遇。</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> index1 != index2:</span><br><span class="line">                    index1 = index1.<span class="built_in">next</span></span><br><span class="line">                    index2 = index2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> index1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/22/day3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/22/day3/" class="post-title-link" itemprop="url">Day3： 203.移除链表元素 707.设计链表 206.反转链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-22 12:56:45" itemprop="dateCreated datePublished" datetime="2023-09-22T12:56:45+10:00">2023-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-23 16:40:18" itemprop="dateModified" datetime="2023-09-23T16:40:18+10:00">2023-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数组结束了，今天开始链表相关的知识了，明天周末可以抽出时间来把数组章节做个总结</p>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题是链表的最基本的删除操作了，链表结点的删除就是直接把该结点前面一个结点的 next 变成它的 next，也就是<code>pre.next = cur.next</code>，我这里偷懒了一下，直接<code>p.next = p.next.next</code><br>另外为了解决头结点自己就是要删的点的情况，在前面再加了一个空的虚拟头结点，最后返回虚拟头结点的 next。</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        virtual_head = ListNode()   <span class="comment"># 定义一个虚拟头结点，方便判断头结点为val的情况</span></span><br><span class="line">        virtual_head.<span class="built_in">next</span> = head</span><br><span class="line">        p = virtual_head            <span class="comment"># 从虚拟头结点开始判断下一个节点是否为val</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果下一个节点是val，删除掉，也就是直接跳到下下个节点</span></span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 没有的话就继续往下遍历</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> virtual_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="comment">// 设置虚拟头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy_head</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy_head-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> dummy_head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;val == val)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tmp</span> =</span> p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 要释放删除那个点的内存</span></span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head = dummy_head-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy_head);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707.设计链表</a><br>这道题考察的内容还挺多的，这次应该算第三次写了，还是有点磕磕绊绊，不过比第一次见到已经好了很多了。</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.dummy_head = ListNode()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 没有相应的索引</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.dummy_head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 遍历找到index点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># self.showList()</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        head = self.dummy_head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 新节点的next为原来的head</span></span><br><span class="line">        node = ListNode(val, head)</span><br><span class="line">        <span class="comment"># 虚拟头结点的next就是新的head</span></span><br><span class="line">        self.dummy_head.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.showList()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = self.dummy_head</span><br><span class="line">        <span class="comment"># 遍历找到最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 新结点的next为None</span></span><br><span class="line">        node = ListNode(val)</span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.showList()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.dummy_head</span><br><span class="line">        <span class="comment"># 遍历找到index前面一个结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        node = ListNode(val, cur.<span class="built_in">next</span>)</span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.showList()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.dummy_head</span><br><span class="line">        <span class="comment"># 跟添加一样，找到前面一个结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.showList()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">showList</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 打印链表，方便debug</span></span><br><span class="line">        cur = self.dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.val, end=<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyLinkedList* <span class="title function_">myLinkedListCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyLinkedList* head = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;val = <span class="number">-1</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// showMyLinkedList(obj);</span></span><br><span class="line">    MyLinkedList* cur = obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=index; i++)&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    MyLinkedList* node = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;next = node;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// showMyLinkedList(obj);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    MyLinkedList* cur = obj;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* node = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cur-&gt;next = node;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// showMyLinkedList(obj);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* cur = obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* node = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;next = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = node;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// showMyLinkedList(obj);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* cur = obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* tmp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(tmp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur-&gt;next = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// showMyLinkedList(obj);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(obj!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MyLinkedList* tmp = obj;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showMyLinkedList</span><span class="params">(MyLinkedList* obj)</span>&#123;</span><br><span class="line">    MyLinkedList* cur = obj;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = myLinkedListCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = myLinkedListGet(obj, index);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtHead(obj, val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtTail(obj, val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtIndex(obj, index, val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myLinkedListDeleteAtIndex(obj, index);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * myLinkedListFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表 </a><br>好久没做了，差点忘记怎么做了，几个指针一直搞不清楚怎么移动，后面画了个图才慢慢理清楚</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 初始cur在head位置，因为反转之后head的next就是None了，所以pre是None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># cur为空就表示到底了，这个时候pre就是原来链表的tail，也就是新链表的head</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 记录一下cur的下一个结点，不然之后cur的next会指向pre</span></span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归到末尾，然后再一层层回来，newhead就是原链表的末尾，也就是反转链表的头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newhead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    <span class="comment">// 每层回来的时候，都会把当前的箭头倒转一下</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解这个递归的方法确实精妙，从尾部回来一层层倒转箭头</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://z5424379.github.io/badline/2023/09/21/day2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/badline/images/avatar.gif">
      <meta itemprop="name" content="Badline">
      <meta itemprop="description" content="主要编程语言: Python, C">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="代码随想录23期算法训练营">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/badline/2023/09/21/day2/" class="post-title-link" itemprop="url">Day2： 977.有序数组的平方，209.长度最小的子数组，59.螺旋矩阵II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-21 18:12:02 / 修改时间：20:12:06" itemprop="dateCreated datePublished" datetime="2023-09-21T18:12:02+10:00">2023-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天是第二天了，感觉更有状态了，今天的题也比较有难度一些了，花了比较多的时间去尝试不同解法，收获还是很大的。</p>
<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方</a><br>这道题看到的第一反应就是用双指针做，头尾往中间开始比大小。做出来还是挺快的，毕竟是简单题。然后还训练一下排序的几个算法，不过 Python 跑都会超时。</p>
<h3 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针:"></a>双指针:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="comment"># 初始化左右指针，分别指向数组的两边</span></span><br><span class="line">        result = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        index = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left]**<span class="number">2</span> &gt; nums[right]**<span class="number">2</span>:  <span class="comment"># 如果左指针的数绝对值较小</span></span><br><span class="line">                result[index] = nums[left] ** <span class="number">2</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[index] = nums[right]**<span class="number">2</span>   <span class="comment"># 如果右指针的数绝对值较小</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]    <span class="comment"># 先计算所有数的平方，然后冒泡排序(会超时)</span></span><br><span class="line">        n = <span class="built_in">len</span>(result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):   <span class="comment"># 每一轮都先把最大的移动到最后</span></span><br><span class="line">            is_sorted = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):   <span class="comment"># 前面i轮已经让最后i位是有序的最大数了，所以只要对n-i-1操作就行</span></span><br><span class="line">                <span class="keyword">if</span> result[j+<span class="number">1</span>] &lt; result[j]:  <span class="comment"># 如果后面的比前面的小，就交换，最后就可以把最大的交换到尾部</span></span><br><span class="line">                    tmp = result[j]</span><br><span class="line">                    result[j] = result[j+<span class="number">1</span>]</span><br><span class="line">                    result[j+<span class="number">1</span>] = tmp</span><br><span class="line">                    is_sorted = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> is_sorted:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]    <span class="comment"># 先计算所有数的平方，然后选择排序</span></span><br><span class="line">        n = <span class="built_in">len</span>(result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):   <span class="comment"># 每一轮都先把最大的移动到最后</span></span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> result[j] &lt; result[min_index]:</span><br><span class="line">                    min_index = j</span><br><span class="line">            tmp = result[min_index]</span><br><span class="line">            result[min_index] = result[i]</span><br><span class="line">            result[i] = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]    <span class="comment"># 先计算所有数的平方，然后插入排序(超时)</span></span><br><span class="line">        n = <span class="built_in">len</span>(result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):   <span class="comment"># 每一轮都先把最小的移动到前面</span></span><br><span class="line">            value = result[i]   <span class="comment"># 每次从无序部分的首元素value的位置开始，向左找</span></span><br><span class="line">            hole = i</span><br><span class="line">            <span class="comment"># 凡是比value大的数，都向右移动一位</span></span><br><span class="line">            <span class="keyword">while</span> hole &gt; <span class="number">0</span> <span class="keyword">and</span> result[hole-<span class="number">1</span>] &gt; value:</span><br><span class="line">                result[hole] = result[hole-<span class="number">1</span>]</span><br><span class="line">                hole -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到value应该在的位置hole，把value放进去</span></span><br><span class="line">            result[hole] = value</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]    <span class="comment"># 先计算所有数的平方，然后快速排序</span></span><br><span class="line">        self.sort(result, <span class="number">0</span>, <span class="built_in">len</span>(result)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self, nums, start, end</span>):</span><br><span class="line">        <span class="keyword">if</span> start &lt; end:</span><br><span class="line">            pt = self.partition(nums, start, end)</span><br><span class="line">            <span class="comment"># 分治法，对基准左右继续进行排序，直到不能再分为止</span></span><br><span class="line">            self.sort(nums, start, pt-<span class="number">1</span>)</span><br><span class="line">            self.sort(nums, pt+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums, start, end</span>):   <span class="comment"># 将数组按照比参考值小，参考值，比参考值大分为三个部分</span></span><br><span class="line">        pivot = nums[end]</span><br><span class="line">        pt = start</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= pivot:    <span class="comment"># 将比参考值小的移到左边，大的移到右边</span></span><br><span class="line">                self.swap(nums, i, pt)</span><br><span class="line">                pt += <span class="number">1</span></span><br><span class="line">        self.swap(nums, pt, end)</span><br><span class="line">        <span class="keyword">return</span> pt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self, nums, a, b</span>):</span><br><span class="line">        tmp = nums[a]</span><br><span class="line">        nums[a] = nums[b]</span><br><span class="line">        nums[b] = tmp</span><br></pre></td></tr></table></figure>

<p>今天的代码都尝试去写注释，发现以前刷题的时候不写注释真的效果很差，因为很多时候其实并没有完全理解这个代码为什么可以通过，看到 ac 就不做了。但是写注释的话，就会强迫自己去搞懂每一段代码具体是做什么的。</p>
<h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h3><h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">if</span>(numsSize==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)&#123;</span><br><span class="line">        nums[k++] = nums[i] * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, <span class="number">0</span>, numsSize<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="type">int</span> pt = partition(nums, start, end);</span><br><span class="line">        sort(nums, start, pt<span class="number">-1</span>);</span><br><span class="line">        sort(nums, pt+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[end];</span><br><span class="line">    <span class="type">int</span> pt = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;end; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;=pivot)&#123;</span><br><span class="line">            swap(nums, i, pt);</span><br><span class="line">            pt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, pt, end);</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 C 的快速排序看到题解的运行时间只有我的接近 1&#x2F;10 了，查一下是快速排序中 partition 函数使用 Lomuto partition scheme 和 Hoare partition scheme 的区别，但是具体两种方法在什么情况使用还没搞明白。</p>
<h4 id="题解快排"><a href="#题解快排" class="headerlink" title="题解快排"></a>题解快排</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Pattion</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=a[low],pivoty=a[low];</span><br><span class="line">	<span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(a[high]&gt;=pivoty&amp;&amp;low&lt;high) high--;</span><br><span class="line">		a[low]=a[high];</span><br><span class="line">		<span class="keyword">while</span>(a[low]&lt;=pivoty&amp;&amp;low&lt;high) low++;</span><br><span class="line">		a[high]=a[low];</span><br><span class="line">	&#125;</span><br><span class="line">	a[low]=temp;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		p=Pattion(a,low,high);</span><br><span class="line">		QuickSort(a,low,p<span class="number">-1</span>);</span><br><span class="line">		QuickSort(a,p+<span class="number">1</span>,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">	*returnSize=n;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		a[k++]=a[i]*a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	QuickSort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：双指针 O(n), 排序 O(n+logn)<br>空间复杂度：O(n)<br>不同排序算法的差距还是很大的，即使都是 O(n+logn)也有差别，我使用快排就会超时。但是使用 Python 自带的 sort 就可以 ac，问了群友了解到 Python 的 sort 是用 tim sort，比快排还要更优。</p>
<hr>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a><br>这道题想到的是滑动窗口，就是维护左右两个指针，不停的滑动，比较所有符合条件的窗口大小，找到最小的。</p>
<h3 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码:"></a>Python 代码:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 初始化左右指针</span></span><br><span class="line">        s = <span class="number">0</span>   <span class="comment"># 计算左右指针之间的数总和</span></span><br><span class="line">        result = inf  <span class="comment"># 初始化result为无穷大，方便后面进行min比较</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="comment"># 移动右指针，直到总和大于target或者到达数组结尾</span></span><br><span class="line">            <span class="keyword">while</span> s &lt; target <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                s += nums[right]</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 移动左指针，直到总和小于target</span></span><br><span class="line">            <span class="keyword">while</span> s &gt;= target <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                result = <span class="built_in">min</span>(result, right-left)</span><br><span class="line">                s -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">if</span> result != inf <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C 代码"></a>C 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)&#123;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; numsSize &amp;&amp; s&lt;target)&#123;</span><br><span class="line">            s = s + nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s&gt;=target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; result)&#123;</span><br><span class="line">                result = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            s = s - nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result == INT_MAX)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<hr>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a><br>这道题第一反应是用暴力破解的做法，就是初始一个二维数组，然后按照走的顺序去把数填上</p>
<h3 id="Python-代码："><a href="#Python-代码：" class="headerlink" title="Python 代码："></a>Python 代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x&lt;=n*n:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n-i):</span><br><span class="line">                nums[i][j] = x    <span class="comment"># 向右</span></span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n-i):</span><br><span class="line">                nums[j][-i-<span class="number">1</span>] = x   <span class="comment"># 向下</span></span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n-i):</span><br><span class="line">                nums[-i-<span class="number">1</span>][-j-<span class="number">1</span>] = x  <span class="comment"># 向左</span></span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n-i-<span class="number">1</span>):</span><br><span class="line">                nums[-j-<span class="number">1</span>][i] = x   <span class="comment"># 向上</span></span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n^2)<br>空间复杂度: O(1)<br>不过这道题 n 取值在 1 到 20，所以 n^2 问题也不大。看了眼题解，也是这样做的，好像确实没有啥更好的办法了。</p>
<h3 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C 代码:"></a>C 代码:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">generateMatrix</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>&#123;</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*n);</span><br><span class="line">    <span class="type">int</span>** nums = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;n; x++)&#123;</span><br><span class="line">        nums[x] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">        (*returnColumnSizes)[x] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num&lt;=n*n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n-i; j++)&#123;</span><br><span class="line">            nums[i][j] = num++; <span class="comment">// 向右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            nums[j][n-i<span class="number">-1</span>] = num++;  <span class="comment">// 向下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            nums[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>] = num++;  <span class="comment">// 向左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            nums[n-j<span class="number">-1</span>][i] = num++;  <span class="comment">// 向上</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/badline/page/2/">2</a><a class="extend next" rel="next" href="/badline/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Badline</p>
  <div class="site-description" itemprop="description">主要编程语言: Python, C</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/badline/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Badline</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/badline/lib/anime.min.js"></script>
  <script src="/badline/lib/velocity/velocity.min.js"></script>
  <script src="/badline/lib/velocity/velocity.ui.min.js"></script>

<script src="/badline/js/utils.js"></script>

<script src="/badline/js/motion.js"></script>


<script src="/badline/js/schemes/pisces.js"></script>


<script src="/badline/js/next-boot.js"></script>




  















  

  


</body>
</html>
